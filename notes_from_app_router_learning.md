**generate metadata**

export const metadata: Metadata = {
title: "Create Next App",
description: "Generated by create next app",
};

you can add it at the layout level and tha overwrite it on the page level if you want to have a dynamic title or
description

**Dynamic metadata**

- you have access to params in generateMetadata function
  `export const generateMetadata({params}): Metadata  {}`
- you can also fetch data in generateMetadata and use this data in there ðŸ¤”
- since there is a fetch request memoization we do not have to worry about refetching data in generateMetadata

- **mounting**
- adding component to the DOM
- unmounting is the opposite

UseEffect runs when the component mounts and unmounts or whenever the dependency changes

cleanup function runs on unmount so that we can get rid of all the effects running in the background - we don't want
them running when the component is not in the DOM anymore

Lets say we are doing something like setting an interval

_usePathname_

- from next/navigation
- use to get the current path

**types**

- file with common types can be added to lib/types

**@/import**
tsconfig.json
paths - default to src

this means @ will point to src catalogue
"paths": {
"@/_": ["./src/_"]
}

**Client-Side Cache**

- stores RSC payload after navigating to some page and going back - data for that page is already rendered and ready
- **loading**

- equivalent of suspense in react

**skeleton component**

- basically some divs with animate pulse

**Array.from({length: 6)}.map(() => {})**

\*_Fetching data on component level with suspense wrapper_

- avoid blocking the whole page when fetching data - you can show some parts of the UI not needing fetched data and
  only supsened components with dynamic data

**CACHING MEMOIZATION**

- memoization last for the duration of the render pass -
  "The cache lasts the lifetime of a server request until the React component tree has finished rendering."
  When a server receives a request to render a page, it may fetch data (e.g., with fetch()).
  React (and Next.js) will cache the results of these fetches for the duration of that single server request.
  This cache is only valid while the server is building the React component tree for that request.
  Once the rendering is done and the response is sent to the client, the cache is discarded.
  If a new request comes in, a new cache is created for that request.
  A user visits or reloads a page that is rendered on the server (SSR/Server Components).
  The client navigates to a new page that requires server-side rendering (e.g., via Next.js app router navigation).
  An API route or server function is called that triggers a new server-side render.
  If a site is static (using Static Site Generation, SSG, in Next.js or similar frameworks):

The page is rendered on the server only during build time (when you run next build or the equivalent build command).
The HTML (and any data fetched during build) is generated once, then saved as static files.
When a user visits the site, the server (or CDN) just serves these pre-built static filesâ€”no server-side rendering
happens at request time.
The fetch cache/memoization applies only during the build process, not at runtime.
Summary:
For static pages, server rendering (and fetch memoization) only happens at build time. All users get the same pre-rendered HTML until you rebuild the site.

Ok if the page is dynamic this server pass will happen on revalidation
Or if it is fully dynamic than it will happen every time user navigates to any page

You are correct!

If the page is dynamic with revalidation (using revalidate or ISR in Next.js):
The server render (server pass) happens:
At build time (for the initial static generation).
Again, whenever the revalidation interval expires and a new request comes in (the page is regenerated on the server and the cache is updated).
If the page is fully dynamic (e.g., dynamic = "force-dynamic" in Next.js):
The server render happens every time a user requests or navigates to that page.
There is no static cache; each request triggers a fresh server-side render and fetch.

- seed db

- useSearchParams for client components
- params, searchParams for async pages

**SUSPENSE**

- add key to make it work on the same route

**zod**

- zod is not used only to validate forms - it can be also very useful to check if data coming from db or any other
  data source is keeping the correct structure

**dynamic vs static**

- static - component run during the build - html is already there during the build it is not created on request
- dynamic - rerendered on request
- using some next.js features will automatically turn some pages into dynamic pages, for example using cookies,
  search params, params etc. since these features are client side features
- generate static params can make some of these dynamic pages static so that next.js can render them statically
  during the build
- generateStaticParams MUST return array of slug objects [{slug: "slug"}] - this way next js knows it needs to run
  them during build and render them -`CLIENT COMPONENTS RUN ON THE SERVER ONCE - during build time`

**PREFETCHING IN LINK COMPONENT**

- on prod - not on dev! - next will prefetch data to components, pages when they are in view.
- It will receive `REACT SERVER COMPONENT PAYLOAD` which is a result of rendering a server component and put it in the
  client-side cache (`ROUTER CACHE`)

**unstable_cache**

- if we are not using fetch that is cached by default we need to do that ourselves
- using unstable cache is caching data from data source for the duration a session - refresh will delete it

**server security and server-only**

- whenever there is some vulnerable users data that you do not want to leek to the client it is good idea to put them
  to a separate catalogue like server-utils etc.
- then you install a package called server-only and import it at the top of the file that you want to keep on the server
- if you try to call this function from within server component this should throw an error

**openGraph**

- test if your page images shows up correctly on social media etc

**server actions**

- onSubmit - you can not do that in a server component!

**useOptimistic**
Usage
Optimistically updating forms

**useActionState**
Usage
Using information returned by a form action
const [state, formAction] = useActionState(createTicket, initState);

//
// useEffect(() => {
// console.log(state, "state");
// if (state.success) {
// toast.success(`ðŸ˜Ž`);
// router.push(`/tickets`);
// }
// console.log(state, `ðŸ†`);
// }, [state]);

**useTransition**
Perform non-blocking updates with Actions
Exposing action prop from components
Displaying a pending visual state
Preventing unwanted loading indicators
Building a Suspense-enabled router
Displaying an error to users with an error boundary
const [isPending, startTransition] = useTransition();
const router = useRouter();

async function handleRegister(formData: FormData) {
startTransition(async () => {
const res = await registerUser(initState, formData);
console.log(res, "res");

      if (res.success === "ok") {
        toast.success(`User registered ðŸš€`);
        router.push(`/tickets`);
      }
      if (res.success === "failed") {
        toast.error(`Something went wrong ðŸš¨:` + res.message);
      }
    });

}

_useFormAction_
Usage
Display a pending state during form submission
Read the form data being submitted

- for actions outside forms like in buttons, stand alone inputs etc.

check if you have access to formDAta in form submit ?

**video 263 265**

- TUTORIAL ZODA I REACT HOOK FORM
- WALIDACJA NA SERWERZE
- REGISTER...
- ZOD RESOLVER

_video 768_

- grid layout
- you can add botu grid-cols-3 and grid-rows-2 for cols/rows
- row-start-1 row-span-1
  it is a BAD PRACTICE to include layout in individual components - it should be visible from the higher level layout
  component, you can use content wrappers or simply pass classes
-

isNan()
substring()
React.lazy()

[614798278-42234/*334+34-34+34=]

_fetch_
async function getData() {
const url = "https://example.org/products.json";
try {
const response = await fetch(url);
if (!response.ok) {
throw new Error(`Response status: ${response.status}`);
}

    const json = await response.json();
    console.log(json);

} catch (error) {
console.error(error.message);
}

- If the server responds with an error like 404 fetch itself will not throw an error - that is why we have to check
  if response is ok - 200, 201 and so on, if it is not we have to throw an Error by ourselves
  -The fetch() function will reject the promise on some errors, but not if the server responds with an error status like 404: so we also check the response status and throw if it is not OK.

Otherwise, we fetch the response body content as JSON by calling the json() method of Response, and log one of its values. Note that like fetch() itself, json() is asynchronous, as are all the other methods to access the response body content.

By default, fetch() makes a GET request, but you can use the method option to use a different request method:

const response = await fetch("https://example.org/post", {
method: "POST",
// â€¦
});

Setting a body
The request body is the payload of the request: it's the thing the client is sending to the server. You cannot include a body with GET requests, but it's useful for requests that send content to the server, such as POST or PUT requests. For example, if you want to upload a file to the server, you might make a POST request and include the file as the request body.

To set a request body, pass it as the body option:

const response = await fetch("https://example.org/post", {
method: "POST",
body: JSON.stringify({ username: "example" }),
// â€¦
});

You can supply the body as an instance of any of the following types:

a string
ArrayBuffer
TypedArray
DataView
Blob
File
URLSearchParams
FormData
ReadableStream

\*_passing data from server c to context_

_server stateless_

- server is stateless - it receives a request from the client, and it sends response - after that it forgets
  everything, it is stateless, that is why we can not do state management on the server like we can on the client -
  hence libraries, and tools like zustand or context api are client side only

**how to correctly pass data from the server to the client using zustand in next js**

**recap of creating a simple server in node / express.js**

**308**

- when passing data to some client component from the server component and this data is updated it wont be updated ?
- better to use date and derive some data/state from it

**onsubmit**

- only runs on the server so no progressive enhancement
  you can still technically use that and trigger server action from that
- what is so powerful with mutatations via server actions everything happens on one network circle - it will send
  the data and get the result immediately

**actions and types**xxzx

- how do you get correct types from formData?

**SOLID**
https://medium.com/@ignatovich.dm/applying-solid-principles-in-react-applications-44eda5e4b664

**useActionState**

- instead of showing error by triggering toast in use effect we can do something like if error <div>error</>
- no javascript needed
- good for progressive enhancement

**flushsync**-

- if you have multiple state setter functions or state updates in a single event react may batch them together, it 
  means that it will try to update the state in single redner pass which is good for optimization but not 
  necessarily what we might want - for example if we want one state update to happen before the other. We can use 
  flushSync to handle such cases
`  import { flushSync } from 'react-dom';

flushSync(() => {
setSomething(123);
});`

YOU SHOULD BE VERY CAREFUL WTIH USING FLUSH SYNC AS I CAN HURT PERFORMANCE AND IT IS NOT WHAT YOU WOULD TYPICALLY 
WANT TO DO 


using this shoul be our last resort since it can hurt performance and usually this is not something we need to do

# flushSync lets you force React to flush any updates inside the provided callback synchronously. This ensures that the DOM is updated immediately.

i've learned that is is usually the last part that is relevant so maybe this is where you should probably be looking 
for a reason of your ts problem


**validation on the server - zod**
You want to validate data on the client to show instant feedback to the user but you also want to validate data on 
the server. 
The reason for this is becuase you can actually manipulate data on the client for example using dev tools so in 
theory the user can bypass our validation. To be sure we need to validate data on the server before sending anything. 
That is why we are using zod.


**zod transform**


**CUID**
CUID (Collision-Resistant Unique Identifier) 
